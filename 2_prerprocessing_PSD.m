%% == License ==========================================================
% This file is part of the project megFingerprinting. All of
% megFingerprinting code is free software: you can redistribute
% it and/or modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation,
% either version 3 of the License, or (at your option) any later version.
% megFingerprinting is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the
% implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
% See the GNU General Public License for
% more details. You should have received a copy of the GNU General Public
% License along with megFingerprinting.
% If not, see <https://www.gnu.org/licen ses/>.

%% == omMachina: OMEGA Preprocessing ==================================
% Based on OMEGA's preprocessing script by Guiomar Niso (26 May 2016)
% 1. Import BIDS dataset (will not work if we are not using this format!)
% 2. Import subject's anatomy
% 3. Prepare MEG and Noise files
% 4. Run PSD on sensors
% 5. Filtering: Line noise and high pass
% 6. SSP: EOG and ECG
% 7. postProcessing: PSD on sensors
% 8. SSP: Sacades and EMG
% 9. Preprocess empty room recordings
% 10. Separate into FOI's
% 11. Data/Noise Covariances
% 12. Compute head model
% 13. Inverse Modelling: Beamformers
% 14. Snapshot: Contact sheet of sources
% 15. Amplitude Envelope Correlation
% 16. Output CSV file
% 17. Save and ouput report
% 18. Delete intermediate files and save beamformer weights

%% == Initiate Brainstorm and protocol setup =============================
% clc; clear;

cd './brainstorm3'

if ~brainstorm('status')
    brainstorm nogui % If brainstorm ain't running, run it with no GUI
end

% Create protocol; if it already exists, load it
omProtocol.name = 'omMachina_4';
if exist('./brainstorm_db/omMachina_4', 'file') == 7
    omProtocol.index = bst_get('Protocol', omProtocol.name);
    bst_set('iProtocol', omProtocol.index);
    
else
    gui_brainstorm('CreateProtocol', omProtocol.name, 0, 0);
end
%% == Parameters =========================================================
% MEG datasets storage
mydirMEG = './data/OMEGA_BIDS';

% Dir to save progress report
mydirBST = './output/reports';

% Dir of database
mydirDB = './data';

% Frequencies to filter with the noth (power line 60Hz and harmonics)
freqs_notch = [60, 120, 180, 240, 300, 360, 420, 480, 540, 600];

% Filters
filt.highpass = 0.3;
filt.lowpass = 0.; % 0: no filter

filter_low.deltaLow = 1.;
filter_high.deltaHigh = 4.;
filter_low.thetaLow = 4.;
filter_high.thetaHigh = 8.;
filter_low.alphaLow = 8.;
filter_high.alphaHigh = 13.;
filter_low.betaLow = 13.;
filter_high.betaHigh = 30.;
filter_low.gammaLow = 30.;
filter_high.gammaHigh = 50.;
filter_low.hgammaLow = 50.;
filter_high.hgammaHigh = 150.;

% Window length and overlap for PSD Welch method
win_length = 2; % sec
win_overlap = 50; % percentage


% .mat files include variables to arrange the atlas into Yeo's RSN
load('./dependencies/desikan_scale33.mat');
load('./dependencies/rsn_mapping_yeo.mat');

% %% == 1) Import BIDS dataset =============================================
% % Import BIDS dataset - This will import all subjects in the file!
sFiles = process_import_bids('ImportBidsDataset', mydirMEG, 15000, 0 , 1)
% % 15000 vertices
% % 0 = non-interactive
% % 1 = allign sensors with head points

sSubjects = bst_get('ProtocolSubjects');
SubjectNames = {sSubjects.Subject.Name}';

%% == 2) Import subject's anatomy =======================================
% Because I am using OMEGA reconstructed anatomy (from the preprocessed
% version), we need to copy the files manually to the database (these are
% downloaded with the bash script). I start at the end because when using
% the delete_subject brainstorm function this updates automatically the
% database, so starting at the end will not fuck up the indexes of the
% subjects even when deleting some of them

for iSubject=(numel(SubjectNames)-1):-1:1
    fold_bool = exist(['./data/OMEGA_BIDS/' SubjectNames{iSubject} '/ses-0001/anat']);
    anat_file_bool = exist(['./data/OMEGA_BIDS/' SubjectNames{iSubject} '/ses-0001/anat/subjectimage_T1.mat']);
    if fold_bool == 7 & anat_file_bool == 2
    source = ['./data/OMEGA_BIDS/' SubjectNames{iSubject} '/ses-0001/anat'];
    destination = ['./brainstorm_db/omMachina_4/anat/' SubjectNames{iSubject}];
    copyfile(source, destination);
    else
        fprintf([SubjectNames{iSubject} ' has no processed anatomy and will be deleted!'])
        db_delete_subjects(iSubject)
    end 
end
db_reload_database('current')


%% == 3) Prepare MEG & Noise files =======================================
% Process: Select file names with tag: noise
sNoise = bst_process('CallProcess', 'process_select_files_data',...
    [], [], ...
    'subjectname',   'sub-emptyroom', ...
    'condition',     '', ...
    'tag',           '', ...
    'includebad',    0, ...
    'includeintra',  0, ...
    'includecommon', 0);

% Get cell aray with emtpy room recording dates
noiseDates = squeeze(zeros(numel(sNoise), 1));
for i=1:numel(sNoise)
    noiseDates(i) = str2num(sNoise(i).FileName(37:44));
end
noiseDates = datetime(num2str(noiseDates), 'InputFormat','yyyyMMdd');

%% Prepare iteration variables so the parfor can run
sSubjects = bst_get('ProtocolSubjects');
SubjectNames = {sSubjects.Subject.Name}';
nSubjects = (numel(SubjectNames)-1);


for iSubject=1:nSubjects
    tic
    % Start a new report
    reportName = [SubjectNames{iSubject} '_report'];
    bst_report('Start', reportName);
    sessions = dir([mydirMEG '/' SubjectNames{iSubject}]);
    sessions = sessions(3:end); % Start from 3, because Linux
    nSessions = numel(sessions);
    
    % for iSession = 1:nSessions % Only analyzing session 1 for everyone!
    fprintf(['Now processing: ' SubjectNames{iSubject} '\n'])
    
    % Process: select data
    sData = bst_process('CallProcess', 'process_select_files_data', ...
        [], [], 'subjectname',   SubjectNames{iSubject});
    
    sData = bst_process('CallProcess', 'process_select_tag', ...
        sData, [], ...
        'tag', 'baselineresting', ...
        'search', 1, ...
        'select', 1);  % Select only the files with the tag
    
    % Process: If there is no baseline resting, analyze post-experiment
    % baseline
    if isempty(sData)
        sData = bst_process('CallProcess', 'process_select_files_data', ...
            [], [], 'subjectname',   SubjectNames{iSubject});
        
        sData = bst_process('CallProcess', 'process_select_tag', ...
            sData, [], ...
            'tag', 'restingaftertask', ...
            'search', 1, ...
            'select', 1);  % Select only the files with the tag
        
        sData = sData(1);
    else
        sData = sData(1);
    end
    
    % Process: Convert to continuous (CTF): Continuous
    cont_bool = load(file_fullpath(sData.FileName), 'F');
    time_bool = load(file_fullpath(sData.FileName), 'Time');
    if ~(strcmp(cont_bool.F.format, 'CTF-CONTINUOUS'))
        sData = bst_process('CallProcess', 'process_ctf_convert', ...
            sData, [], 'rectype', 2);
    end
    
    % Sometimes the files are not continous but they only contain one long
    % epoch. This bit controls for that
    if isempty(sData)
        if time_bool.Time(2) > 2
            % Process: select data
            sData = bst_process('CallProcess', 'process_select_files_data', ...
                [], [], 'subjectname',   SubjectNames{iSubject});
            
            sData = bst_process('CallProcess', 'process_select_tag', ...
                sData, [], ...
                'tag', 'baselineresting', ...
                'search', 1, ...
                'select', 1);  % Select only the files with the tag
        end
    end
    
    % Process: If there is no baseline resting, analyze post-experiment
    % baseline
    if isempty(sData)
        sData = bst_process('CallProcess', 'process_select_files_data', ...
            [], [], 'subjectname',   SubjectNames{iSubject});
        
        sData = bst_process('CallProcess', 'process_select_tag', ...
            sData, [], ...
            'tag', 'restingaftertask', ...
            'search', 1, ...
            'select', 1);  % Select only the files with the tag
        
        sData = sData(1);
    else
        sData = sData(1);
    end    
    
    
    % Process: Refine registration
    sRefined = bst_process('CallProcess', ...
        'process_headpoints_refine', sData, []);
    
    % Process: Select file names with tag: rest
    sFilesR = bst_process('CallProcess', 'process_select_tag', ...
        sRefined, [], ...
        'tag', 'baselineresting', ... % Differentiate from other files
        'search', 1, ... % 1: Filename, 2: Comments
        'select', 1);  % Select only the files with the tag
    
    % Process: If there is no baseline resting, analyze post-experiment
    % baseline
    if isempty(sFilesR)
        sFilesR = bst_process('CallProcess', 'process_select_tag', ...
            sRefined, [], ...
            'tag', 'restingaftertask', ... % Differentiate from other files
            'search', 1, ... % 1: Filename, 2: Comments
            'select', 1);  % Select only the files with the tag
        
        sFilesR = sFilesR(1);
    else
        sFilesR = sFilesR(1);
    end
    
    % Process: Snapshot of Sensors/MRI registration (goes into report)
    bst_process('CallProcess', 'process_snapshot', ...
        sFilesR, [], ...
        'target', 1, ...  % Sensors/MRI registration
        'modality', 1, ...% MEG (All)
        'orient', 1, ...  % left
        'time', 0, ...
        'contact_time', [0, 0.1], ...
        'contact_nimage', 12, ...
        'threshold', 30, ...
        'comment', '');
    
    %% == 4) preProcessing PSD on sensors ============================
    % Process: Power spectrum density (Welch) pre-filtering
    sFilesPSDpre = bst_process('CallProcess', 'process_psd', ...
        sFilesR, [], ...
        'timewindow', [], ...
        'win_length', win_length, ...
        'win_overlap', win_overlap, ...
        'sensortypes', 'MEG, EEG', ...
        'edit', struct(...
        'Comment', 'Power', ...
        'TimeBands', [], ...
        'Freqs', [], ...
        'ClusterFuncTime', 'none', ...
        'Measure', 'power', ...
        'Output', 'all', ...
        'SaveKernel', 0));
    
    % Process: Snapshot of Frequency spectrum prefiltering (goes into report))
    bst_process('CallProcess', 'process_snapshot', ...
        sFilesPSDpre, [], ...
        'target', 10, ...  % Frequency spectrum
        'modality', 1, ...  % MEG (All)
        'orient', 1, ...  % left
        'time', 0, ...
        'contact_time', [0, 0.1], ...
        'contact_nimage', 12, ...
        'threshold', 30, ...
        'comment', 'prePreprocessing');
    
    
    
    %% == 5) Filtering: Line noise and high pass =====================
    % Process: Notch filter(60Hz + 10 Harmonics)
    
    sFilesR = bst_process('CallProcess', 'process_ssp_apply', sFilesR, []);
    
    sFilesNotch = bst_process('CallProcess', 'process_notch', ...
        sFilesR, [], ...
        'freqlist', freqs_notch, ...
        'sensortypes', 'MEG, EEG', ...
        'read_all', 0);

    % Process: High-pass:0.3Hz
    sFilesMEG = bst_process('CallProcess', 'process_bandpass', ...
        sFilesNotch, [], ...
        'highpass', filt.highpass, ...
        'lowpass', filt.lowpass, ...
        'mirror', 0, ...
        'sensortypes', 'MEG, EEG', ...
        'read_all', 0);
    
    % Delete intermediate files (Notch)
    for iRun=1:numel(sFilesNotch)
        % Process: Delete data files
        bst_process('CallProcess', 'process_delete', ...
            sFilesNotch(iRun).FileName, [], ...
            'target', 2);  % Delete conditions
    end
    
    
    %% == 6) SSP: EOG and ECG ========================================
    % Process: Select file names with tag: resting
    sFilesRESTING = bst_process('CallProcess', 'process_select_tag', ...
        sFilesMEG, [], ...
        'tag', 'baselineresting', ...
        'search', 1, ...
        'select', 1);  % Select only the files with the tag
    
    % Process: If there is no baseline resting, analyze post-experiment
    % baseline
    if isempty(sFilesRESTING)
        sFilesRESTING = bst_process('CallProcess', 'process_select_tag', ...
            sFilesMEG, [], ...
            'tag', 'restingaftertask', ... % Differentiate from other files
            'search', 1, ... % 1: Filename, 2: Comments
            'select', 1);  % Select only the files with the tag
        
        sFilesRESTING = sFilesRESTING(1);
    else
        sFilesRESTING = sFilesRESTING(1);
    end
    
    % SSP detect and remove blinks per run
    for iRun=1:numel(sFilesRESTING)
        % Read the channel file
        ChannelMat = in_bst_channel(sFilesRESTING(iRun).ChannelFile);
        
        % Look for ECG channel
        iChannelECG = channel_find(ChannelMat.Channel, 'ECG');
        
        % Look for EOG channel
        iChannelVEOG = channel_find(ChannelMat.Channel, 'VEOG');
        
        % Process: Detect heartbeats
        if ~isempty(iChannelECG)
            bst_process('CallProcess', 'process_evt_detect_ecg', ...
                sFilesRESTING(iRun), [], ...
                'channelname', ChannelMat.Channel(iChannelECG).Name,...
                'timewindow', [], ...
                'eventname', 'cardiac');
        else
            disp('No ECG channel found!')
        end
        
        % Process: Detect eye blinks
        if ~isempty(iChannelVEOG)
            bst_process('CallProcess', 'process_evt_detect_eog', ...
                sFilesRESTING(iRun), [], ...
                'channelname', ChannelMat.Channel(iChannelVEOG).Name, ...
                'timewindow', [], ...
                'eventname', 'blink');
        else
            disp('No EOG channel found!')
        end
    end
    
    % Process: Remove simultaneous (keep blinks over heart beats)
    bst_process('CallProcess', 'process_evt_remove_simult', ...
        sFilesRESTING, [], ...
        'remove', 'cardiac', ...
        'target', 'blink', ...
        'dt', 0.25, ...
        'rename', 0);
    
    % Process: SSP ECG (cardiac) force remove 1st component
    bst_process('CallProcess', 'process_ssp_ecg', ...
        sFilesRESTING, [], ...
        'eventname', 'cardiac', ...
        'sensortypes', 'MEG', ...
        'usessp', 1, ...
        'select', 1);
    
    % Process: SSP EOG (blink) force remove 1st component
    bst_process('CallProcess', 'process_ssp_eog', ...
        sFilesRESTING, [], ...
        'eventname', 'blink', ...
        'sensortypes', 'MEG', ...
        'usessp', 1, ...
        'select', 1);
    
    % Process: Snapshot: SSP projectors
    bst_process('CallProcess', 'process_snapshot', ...
        sFilesRESTING, [], ...
        'target', 2, ...  % SSP projectors
        'modality', 1, ...  % MEG (All)
        'orient', 1, ...  % left
        'time', 0, ...
        'contact_time', [0, 0.1], ...
        'contact_nimage', 12, ...
        'threshold', 30, ...
        'comment', '');
    
    %% == 7) postProcessing PSD on sensors ===========================
    % Process: Power spectrum density (Welch)
    sFilesPSDpost = bst_process('CallProcess', 'process_psd', ...
        sFilesRESTING, [], ...
        'timewindow', [], ...
        'win_length', win_length, ...
        'win_overlap', win_overlap, ...
        'sensortypes', 'MEG, EEG', ...
        'edit', struct(...
        'Comment', 'Power', ...
        'TimeBands', [], ...
        'Freqs', [], ...
        'ClusterFuncTime', 'none', ...
        'Measure', 'power', ...
        'Output', 'all', ...
        'SaveKernel', 0));
    
    % Process: Snapshot: Frequency spectrum
    bst_process('CallProcess', 'process_snapshot', ...
        sFilesPSDpost, [], ...
        'target', 10, ...  % Frequency spectrum
        'modality', 1, ...  % MEG (All)
        'orient', 1, ...  % left
        'time', 0, ...
        'contact_time', [0, 0.1], ...
        'contact_nimage', 12, ...
        'threshold', 30, ...
        'comment', 'After filtering and EOG/ECG SSP');
    
    %% == 8) SSP: Sacades and EMG ====================================
    % Process: Detect other artifacts (mark noisy segments)
    bst_process('CallProcess', 'process_evt_detect_badsegment', ...
        sFilesRESTING, [], ...
        'timewindow', [], ...
        'sensortypes', 'MEG, EEG', ...
        'threshold', 3, ...  % 3
        'isLowFreq', 1, ...
        'isHighFreq', 1);
    
    % Process: SSP for low frequencies (saccades) 1 - 7 Hz (remove 1st)
    bst_process('CallProcess', 'process_ssp', ...
        sFilesRESTING, [], ...
        'timewindow',  [], ...
        'eventname',   '1-7Hz', ...
        'eventtime',   [], ...
        'bandpass',    [1, 7], ...
        'sensortypes', 'MEG', ...
        'usessp',      1, ...
        'saveerp',     0, ...
        'method',      1, ...  % PCA: One component per sensor
        'select',      1);
    
    % Process: SSP for high frequencies (muscle) 40 - 400 Hz (remove 1st)
    bst_process('CallProcess', 'process_ssp', ...
        sFilesRESTING, [], ...
        'timewindow',  [], ...
        'eventname',   '', ...
        'eventtime',   [], ...
        'bandpass',    [40, 400], ...
        'sensortypes', 'MEG', ...
        'usessp',      1, ...
        'saveerp',     0, ...
        'method',      1, ...  % PCA: One component per sensor
        'select',      1);
    
    
    %% == 9) Preprocess empty room recordings ========================
    % Process: find the empty room recordings closest to this date
    temp_date = load(['./brainstorm_db/omMachina_4/data/' sData.FileName]);
    sub_date = [datetime(temp_date.F.header.res4.data_date, 'InputFormat', 'dd-MM-yyyy')];
    [~, ind1] = min(abs(datenum(noiseDates) - datenum(sub_date)));
    sub_noise = noiseDates(ind1, :);
    sub_noise = string(datestr(sub_noise, 'yyyymmdd'));
    
    % Process: Select noise recordings closest to participants testing date
    sSubNoise = bst_process('CallProcess', 'process_select_tag', ...
        sNoise, [], ...
        'tag', sub_noise, ...
        'search', 1, ...
        'select', 1);  % Select only the files with the tag
    
    if ~(numel(sSubNoise) == 1)
        sSubNoise = sSubNoise(1);
    end
    
    
    % Preprocess empty room recording!
    % Process: Convert to continuous (CTF): Continuous
    cont_bool = load(file_fullpath(sSubNoise.FileName), 'F');
    time_bool = load(file_fullpath(sSubNoise.FileName), 'Time');
    if ~(strcmp(cont_bool.F.format, 'CTF-CONTINUOUS'))
        sSubNoise = bst_process('CallProcess', 'process_ctf_convert', ...
            sSubNoise, [], 'rectype', 2);
    end
    
    % Sometimes the files are not continous but they only contain one long
    % epoch. This bit controls for that
    if isempty(sSubNoise)
        if time_bool.Time(2) > 2
            sSubNoise = bst_process('CallProcess', 'process_select_tag', ...
                sNoise, [], ...
                'tag', sub_noise, ...
                'search', 1, ...
                'select', 1);  % Select only the files with the tag
        end
    end
    
    
    
    % Process: Notch filter line noise
    sNoiseFilesNotch = bst_process('CallProcess', 'process_notch', ...
        sSubNoise, [], ...
        'freqlist', freqs_notch, ...
        'sensortypes', 'MEG, EEG', ...
        'read_all', 1);
    
    % Process: High-pass:0.3Hz
    sFilesMEGNoise = bst_process('CallProcess', 'process_bandpass', ...
        sNoiseFilesNotch, [], ...
        'highpass', filt.highpass, ...
        'lowpass', filt.lowpass, ...
        'mirror', 0, ...
        'sensortypes', 'MEG, EEG', ...
        'read_all', 1);
    
    %% == 10) Separate into FOI's =====================================
    sFOI = struct('delta', ' ', 'theta', ' ', 'alpha', ' ', ...
        'beta', ' ', 'gamma', ' ', 'hgamma', ' ');
    sNoiseFOI = struct('delta', ' ', 'theta', ' ', 'alpha', ' ', ...
        'beta', ' ', 'gamma', ' ', 'hgamma', ' ');
    sFOI_names = fieldnames(sFOI);
    filtL_names = fieldnames(filter_low);
    filtH_names = fieldnames(filter_high);
    nFOI = numel(sFOI_names);
    
    for iFOI = 1:nFOI
        sFOI.(sFOI_names{iFOI}) = bst_process('CallProcess', 'process_bandpass', ...
            sFilesRESTING, [], ...
            'highpass',    filter_low.(filtL_names{iFOI}), ...
            'lowpass',     filter_high.(filtH_names{iFOI}), ...
            'attenuation', 'strict', ...  % 60dB
            'sensortypes', 'MEG',...
            'mirror',      0, ...
            'read_all',    1, ...  % Channels have SSP projections, read it all
            'Method', 'bst-hfilter'); % This implements a Kaiser window FIR
        
        sFOI.(sFOI_names{iFOI}) = bst_process('CallProcess', 'process_add_tag', ...
            sFOI.(sFOI_names{iFOI}), [], ...
            'tag',    sFOI_names{iFOI}, ...
            'output', 2);  % Add to file name
        
        % Process: Power spectrum density (Welch)
        sFilesPSDpost = bst_process('CallProcess', 'process_psd', ...
            sFOI.(sFOI_names{iFOI}), [], ...
            'timewindow', [], ...
            'win_length', win_length, ...
            'win_overlap', win_overlap, ...
            'sensortypes', 'MEG', ...
            'edit', struct(...
            'Comment', 'Power', ...
            'TimeBands', [], ...
            'Freqs', [], ...
            'ClusterFuncTime', 'none', ...
            'Measure', 'power', ...
            'Output', 'all', ...
            'SaveKernel', 0));
        
        % Process: Snapshot: Frequency spectrum
        bst_process('CallProcess', 'process_snapshot', ...
            sFilesPSDpost, [], ...
            'target', 10, ...  % Frequency spectrum
            'modality', 1, ...  % MEG (All)
            'orient', 1, ...  % left
            'time', 0, ...
            'contact_time', [0, 0.1], ...
            'contact_nimage', 12, ...
            'threshold', 30, ...
            'comment', sFOI_names{iFOI});
        
        % Noise recording
        sNoiseFOI.(sFOI_names{iFOI}) = bst_process('CallProcess', 'process_bandpass', ...
            sFilesMEGNoise, [], ...
            'highpass',    filter_low.(filtL_names{iFOI}), ...
            'lowpass',     filter_high.(filtH_names{iFOI}), ...
            'attenuation', 'strict', ...  % 60dB
            'sensortypes', 'MEG',...
            'mirror',      0, ...
            'read_all',    1, ...
            'Method', 'bst-hfilter'); % This implements a Kaiser window FIR
        
        sNoiseFOI.(sFOI_names{iFOI}) = bst_process('CallProcess', 'process_add_tag', ...
            sNoiseFOI.(sFOI_names{iFOI}), [], ...
            'tag',    sFOI_names{iFOI}, ...
            'output', 2);  % Add to file name
    end
    
    % Brainstorm gets confused when you do things with scripting, so
    % I'm reloading the database just in case
    db_reload_database('current')
    
    
    
    %% == 11) Data/Noise Covariance ==================================
    for iFOI = 1:nFOI
        % Import both files into the database
        sFOI.(sFOI_names{iFOI}) = bst_process('CallProcess', 'process_import_data_time', ...
            sFOI.(sFOI_names{iFOI}).FileName, [], ...
            'subjectname', SubjectNames{iSubject}, ...
            'condition',   ['meg_' sFOI_names{iFOI}], ...
            'timewindow',  [], ...
            'split',       0, ...
            'ignoreshort', 0, ...
            'usectfcomp',  1, ...
            'usessp',      1, ...
            'freq',        [], ...
            'baseline',    []);
        
        sNoiseFOI.(sFOI_names{iFOI}) = bst_process('CallProcess', 'process_import_data_time', ...
            sNoiseFOI.(sFOI_names{iFOI}), [], ...
            'subjectname', SubjectNames{iSubject}, ...
            'condition',   ['emptyroom_' sFOI_names{iFOI}], ...
            'timewindow',  [], ...
            'split',       0, ...
            'ignoreshort', 0, ...
            'usectfcomp',  1, ...
            'usessp',      1, ...
            'freq',        [], ...
            'baseline',    []);
        
        % Standardize the number of channels
        sFilesTEMP = bst_process('CallProcess', 'process_stdchan', ...
            {sFOI.(sFOI_names{iFOI}).FileName, ...
            sNoiseFOI.(sFOI_names{iFOI}).FileName}, [], ...
            'method',  1);  % Keep only the common channel names=> Remove all the others
        
        sFOI.(sFOI_names{iFOI}) = sFilesTEMP(1);
        sNoiseFOI.(sFOI_names{iFOI}) = sFilesTEMP(2);
        
        % Compute the data covariance
        sTime = load(file_fullpath(sFOI.(sFOI_names{iFOI}).FileName), 'Time');
        bst_process('CallProcess', 'process_noisecov', ...
            sFOI.(sFOI_names{iFOI}), [], ...
            'baseline',       [sTime.Time(1) sTime.Time(end)], ...
            'datatimewindow', [sTime.Time(1) sTime.Time(end)], ...
            'sensortypes',    'MEG', ...
            'target',         2, ...  % Data covariance
            'dcoffset',       1, ...  % Block by block
            'identity',       0, ...
            'copycond',       0, ...
            'copysubj',       0, ...
            'copymatch',      0, ...
            'replacefile',    1);  % Replace
        
        % Compute the noise covariance
        bst_process('CallProcess', 'process_noisecov', ...
            sNoiseFOI.(sFOI_names{iFOI}), [], ...
            'baseline',       [], ...
            'datatimewindow', [], ...
            'sensortypes',    'MEG', ...
            'target',         1, ...  % Noise covariance
            'dcoffset',       1, ...  % Block by block
            'identity',       0, ...
            'copycond',       0, ...
            'copysubj',       0, ...
            'copymatch',      0, ...
            'replacefile',    1);  % Replace
        
        % Copy subject's noise covariance
        source = ['./brainstorm_db/omMachina_4/data/' SubjectNames{iSubject} '/emptyroom_' sFOI_names{iFOI} '/noisecov_full.mat'];
        destination = ['./brainstorm_db/omMachina_4/data/' SubjectNames{iSubject} '/meg_' sFOI_names{iFOI} '/'];
        copyfile(source, destination);
    end
    
    % Brainstorm gets confused when you do things with scripting, so
    % I'm reloading the database just in case
    db_reload_database('current')
    
    %% == 12) Compute head model =====================================
    for iFOI = 1:nFOI
        bst_process('CallProcess', 'process_headmodel',...
            sFOI.(sFOI_names{iFOI}), [], ...
            'Comment',     '', ...
            'sourcespace', 1, ...  % Cortex surface
            'volumegrid',  struct(...
            'Method',        'isotropic', ...
            'nLayers',       17, ...
            'Reduction',     3, ...
            'nVerticesInit', 4000, ...
            'Resolution',    0.005, ...
            'FileName',      ''), ...
            'meg',         3, ...  % Overlapping spheres
            'eeg',         1, ...  %
            'ecog',        1, ...  %
            'seeg',        1, ...  %
            'openmeeg',    struct(...
            'BemFiles',     {{}}, ...
            'BemNames',     {{'Scalp', 'Skull', 'Brain'}}, ...
            'BemCond',      [1, 0.0125, 1], ...
            'BemSelect',    [1, 1, 1], ...
            'isAdjoint',    0, ...
            'isAdaptative', 1, ...
            'isSplit',      0, ...
            'SplitLength',  4000));
    end
    
    %% == 13) Inverse Modelling: Beamformers =========================
    for iFOI = 1:nFOI
        bst_process('CallProcess', 'process_inverse_2016',...
            sFOI.(sFOI_names{iFOI}), [], ...
            'output',  1, ...  % Kernel only: shared
            'inverse', struct(...
            'Comment',        'PNAI: MEG', ...
            'InverseMethod',  'lcmv', ...
            'InverseMeasure', 'nai', ...
            'SourceOrient',   {{'fixed'}}, ...
            'Loose',          0.2, ...
            'UseDepth',       1, ...
            'WeightExp',      0.5, ...
            'WeightLimit',    10, ...
            'NoiseMethod',    'median', ...
            'NoiseReg',       0.1, ...
            'SnrMethod',      'rms', ...
            'SnrRms',         1e-06, ...
            'SnrFixed',       3, ...
            'ComputeKernel',  1, ...
            'DataTypes',      {{'MEG'}}));
    end
    
    %% == 14) Snapshot: Contact sheet of sources =========================
    sSources = struct('delta', ' ', 'theta', ' ', 'alpha', ' ', ...
        'beta', ' ', 'gamma', ' ', 'hgamma', ' ', 'validation', ' ', ...
        'training', '');
    sSources.training = struct('delta', ' ', 'theta', ' ', 'alpha', ' ', ...
        'beta', ' ', 'gamma', ' ', 'hgamma', ' ');
    sSources.validation = struct('delta', ' ', 'theta', ' ', 'alpha', ' ', ...
        'beta', ' ', 'gamma', ' ', 'hgamma', ' ');
    
        PSD = struct('delta', ' ', 'theta', ' ', 'alpha', ' ', ...
        'beta', ' ', 'gamma', ' ', 'hgamma', ' ', 'validation', ' ', ...
        'training', '');
    PSD.training = struct('delta', ' ', 'theta', ' ', 'alpha', ' ', ...
        'beta', ' ', 'gamma', ' ', 'hgamma', ' ');
    PSD.validation = struct('delta', ' ', 'theta', ' ', 'alpha', ' ', ...
        'beta', ' ', 'gamma', ' ', 'hgamma', ' ');
    
    
    for iFOI = 1:nFOI
        sSources.(sFOI_names{iFOI}) = bst_process('CallProcess', 'process_select_files_results', ...
            [], [], ...
            'subjectname',   SubjectNames{iSubject}, ...
            'condition',     ['meg_' (sFOI_names{iFOI})], ...
            'tag',           '', ...
            'includebad',    0, ...
            'includeintra',  0, ...
            'includecommon', 0);
        
        bst_process('CallProcess', 'process_snapshot', ...
            sSources.(sFOI_names{iFOI}), [], ...
            'target',         9, ...  % Sources (contact sheet)
            'modality',       1, ...  % MEG (All)
            'orient',         1, ...  % left
            'time',           [], ...
            'contact_time',   [sTime.Time(1) sTime.Time(end)], ...
            'contact_nimage', 16, ...
            'threshold',      15, ...
            'Comment',    sFOI_names{iFOI});
    end
    
    %% == 15.2) Calculate scouts and PSD ==================================
    
    for iFOI = 1:nFOI
        
        %% Scouts
        
        % Process: Power spectrum density (Welch)
        sSources.training.(sFOI_names{iFOI}) = bst_process('CallProcess', 'process_psd', sSources.(sFOI_names{iFOI}).FileName, [], ...
            'timewindow',  [(5), (floor((sTime.Time(end))/2))], ...
            'win_length',  win_length, ...
            'win_overlap', win_overlap, ...
            'clusters',    {'Desikan-Killiany', {'bankssts L', 'bankssts R', 'caudalanteriorcingulate L', 'caudalanteriorcingulate R', 'caudalmiddlefrontal L', 'caudalmiddlefrontal R', 'cuneus L', 'cuneus R', 'entorhinal L', 'entorhinal R', 'frontalpole L', 'frontalpole R', 'fusiform L', 'fusiform R', 'inferiorparietal L', 'inferiorparietal R', 'inferiortemporal L', 'inferiortemporal R', 'insula L', 'insula R', 'isthmuscingulate L', 'isthmuscingulate R', 'lateraloccipital L', 'lateraloccipital R', 'lateralorbitofrontal L', 'lateralorbitofrontal R', 'lingual L', 'lingual R', 'medialorbitofrontal L', 'medialorbitofrontal R', 'middletemporal L', 'middletemporal R', 'paracentral L', 'paracentral R', 'parahippocampal L', 'parahippocampal R', 'parsopercularis L', 'parsopercularis R', 'parsorbitalis L', 'parsorbitalis R', 'parstriangularis L', 'parstriangularis R', 'pericalcarine L', 'pericalcarine R', 'postcentral L', 'postcentral R', 'posteriorcingulate L', 'posteriorcingulate R', 'precentral L', 'precentral R', 'precuneus L', 'precuneus R', 'rostralanteriorcingulate L', 'rostralanteriorcingulate R', 'rostralmiddlefrontal L', 'rostralmiddlefrontal R', 'superiorfrontal L', 'superiorfrontal R', 'superiorparietal L', 'superiorparietal R', 'superiortemporal L', 'superiortemporal R', 'supramarginal L', 'supramarginal R', 'temporalpole L', 'temporalpole R', 'transversetemporal L', 'transversetemporal R'}}, ...
            'scoutfunc',   3, ...  % PCA
            'win_std',     0, ...
         'edit',        struct(...
         'Comment',         'Scouts,Power', ...
         'TimeBands',       [], ...
         'Freqs',           [], ...
         'ClusterFuncTime', 'before', ...
         'Measure',         'power', ...
         'Output',          'all', ...
         'SaveKernel',      0));
        
             % Process: Power spectrum density (Welch)
        sSources.validation.(sFOI_names{iFOI}) = bst_process('CallProcess', 'process_psd', sSources.(sFOI_names{iFOI}).FileName, [], ...
            'timewindow',  [ceil((sTime.Time(end))/2), (sTime.Time(end) - 5)], ...
            'win_length',  win_length, ...
            'win_overlap', win_overlap, ...
            'clusters',    {'Desikan-Killiany', {'bankssts L', 'bankssts R', 'caudalanteriorcingulate L', 'caudalanteriorcingulate R', 'caudalmiddlefrontal L', 'caudalmiddlefrontal R', 'cuneus L', 'cuneus R', 'entorhinal L', 'entorhinal R', 'frontalpole L', 'frontalpole R', 'fusiform L', 'fusiform R', 'inferiorparietal L', 'inferiorparietal R', 'inferiortemporal L', 'inferiortemporal R', 'insula L', 'insula R', 'isthmuscingulate L', 'isthmuscingulate R', 'lateraloccipital L', 'lateraloccipital R', 'lateralorbitofrontal L', 'lateralorbitofrontal R', 'lingual L', 'lingual R', 'medialorbitofrontal L', 'medialorbitofrontal R', 'middletemporal L', 'middletemporal R', 'paracentral L', 'paracentral R', 'parahippocampal L', 'parahippocampal R', 'parsopercularis L', 'parsopercularis R', 'parsorbitalis L', 'parsorbitalis R', 'parstriangularis L', 'parstriangularis R', 'pericalcarine L', 'pericalcarine R', 'postcentral L', 'postcentral R', 'posteriorcingulate L', 'posteriorcingulate R', 'precentral L', 'precentral R', 'precuneus L', 'precuneus R', 'rostralanteriorcingulate L', 'rostralanteriorcingulate R', 'rostralmiddlefrontal L', 'rostralmiddlefrontal R', 'superiorfrontal L', 'superiorfrontal R', 'superiorparietal L', 'superiorparietal R', 'superiortemporal L', 'superiortemporal R', 'supramarginal L', 'supramarginal R', 'temporalpole L', 'temporalpole R', 'transversetemporal L', 'transversetemporal R'}}, ...
            'scoutfunc',   3, ...  % PCA
            'win_std',     0, ...
         'edit',        struct(...
         'Comment',         'Scouts,Power', ...
         'TimeBands',       [], ...
         'Freqs',           [], ...
         'ClusterFuncTime', 'before', ...
         'Measure',         'power', ...
         'Output',          'all', ...
         'SaveKernel',      0));

    
    end
    
    
%         %% == 15.2) Calculate scouts and PSD for short 30 s windows ==================================
%             sSources = struct('delta', ' ', 'theta', ' ', 'alpha', ' ', ...
%         'beta', ' ', 'gamma', ' ', 'hgamma', ' ', 'validation', ' ', ...
%         'training', '');
%     sSources.trainingone = struct('delta', ' ', 'theta', ' ', 'alpha', ' ', ...
%         'beta', ' ', 'gamma', ' ', 'hgamma', ' ');
%         sSources.trainingtwo = struct('delta', ' ', 'theta', ' ', 'alpha', ' ', ...
%         'beta', ' ', 'gamma', ' ', 'hgamma', ' ');
%     sSources.validation = struct('delta', ' ', 'theta', ' ', 'alpha', ' ', ...
%         'beta', ' ', 'gamma', ' ', 'hgamma', ' ');
%     
%     
%     for iFOI = 1:nFOI
%         
%         %% Scouts
%         
%         % Process: Power spectrum density (Welch)
%         sSources.trainingone.(sFOI_names{iFOI}) = bst_process('CallProcess', 'process_psd', sSources.(sFOI_names{iFOI}).FileName, [], ...
%             'timewindow',  [(5), (35)], ...
%             'win_length',  win_length, ...
%             'win_overlap', win_overlap, ...
%             'clusters',    {'Desikan-Killiany', {'bankssts L', 'bankssts R', 'caudalanteriorcingulate L', 'caudalanteriorcingulate R', 'caudalmiddlefrontal L', 'caudalmiddlefrontal R', 'cuneus L', 'cuneus R', 'entorhinal L', 'entorhinal R', 'frontalpole L', 'frontalpole R', 'fusiform L', 'fusiform R', 'inferiorparietal L', 'inferiorparietal R', 'inferiortemporal L', 'inferiortemporal R', 'insula L', 'insula R', 'isthmuscingulate L', 'isthmuscingulate R', 'lateraloccipital L', 'lateraloccipital R', 'lateralorbitofrontal L', 'lateralorbitofrontal R', 'lingual L', 'lingual R', 'medialorbitofrontal L', 'medialorbitofrontal R', 'middletemporal L', 'middletemporal R', 'paracentral L', 'paracentral R', 'parahippocampal L', 'parahippocampal R', 'parsopercularis L', 'parsopercularis R', 'parsorbitalis L', 'parsorbitalis R', 'parstriangularis L', 'parstriangularis R', 'pericalcarine L', 'pericalcarine R', 'postcentral L', 'postcentral R', 'posteriorcingulate L', 'posteriorcingulate R', 'precentral L', 'precentral R', 'precuneus L', 'precuneus R', 'rostralanteriorcingulate L', 'rostralanteriorcingulate R', 'rostralmiddlefrontal L', 'rostralmiddlefrontal R', 'superiorfrontal L', 'superiorfrontal R', 'superiorparietal L', 'superiorparietal R', 'superiortemporal L', 'superiortemporal R', 'supramarginal L', 'supramarginal R', 'temporalpole L', 'temporalpole R', 'transversetemporal L', 'transversetemporal R'}}, ...
%             'scoutfunc',   3, ...  % PCA
%             'win_std',     0, ...
%          'edit',        struct(...
%          'Comment',         'Scouts,Power', ...
%          'TimeBands',       [], ...
%          'Freqs',           [], ...
%          'ClusterFuncTime', 'before', ...
%          'Measure',         'power', ...
%          'Output',          'all', ...
%          'SaveKernel',      0));
%         
%              % Process: Power spectrum density (Welch)
%         sSources.trainingone.(sFOI_names{iFOI}) = bst_process('CallProcess', 'process_psd', sSources.(sFOI_names{iFOI}).FileName, [], ...
%             'timewindow',  [(35), (65)], ...
%             'win_length',  win_length, ...
%             'win_overlap', win_overlap, ...
%             'clusters',    {'Desikan-Killiany', {'bankssts L', 'bankssts R', 'caudalanteriorcingulate L', 'caudalanteriorcingulate R', 'caudalmiddlefrontal L', 'caudalmiddlefrontal R', 'cuneus L', 'cuneus R', 'entorhinal L', 'entorhinal R', 'frontalpole L', 'frontalpole R', 'fusiform L', 'fusiform R', 'inferiorparietal L', 'inferiorparietal R', 'inferiortemporal L', 'inferiortemporal R', 'insula L', 'insula R', 'isthmuscingulate L', 'isthmuscingulate R', 'lateraloccipital L', 'lateraloccipital R', 'lateralorbitofrontal L', 'lateralorbitofrontal R', 'lingual L', 'lingual R', 'medialorbitofrontal L', 'medialorbitofrontal R', 'middletemporal L', 'middletemporal R', 'paracentral L', 'paracentral R', 'parahippocampal L', 'parahippocampal R', 'parsopercularis L', 'parsopercularis R', 'parsorbitalis L', 'parsorbitalis R', 'parstriangularis L', 'parstriangularis R', 'pericalcarine L', 'pericalcarine R', 'postcentral L', 'postcentral R', 'posteriorcingulate L', 'posteriorcingulate R', 'precentral L', 'precentral R', 'precuneus L', 'precuneus R', 'rostralanteriorcingulate L', 'rostralanteriorcingulate R', 'rostralmiddlefrontal L', 'rostralmiddlefrontal R', 'superiorfrontal L', 'superiorfrontal R', 'superiorparietal L', 'superiorparietal R', 'superiortemporal L', 'superiortemporal R', 'supramarginal L', 'supramarginal R', 'temporalpole L', 'temporalpole R', 'transversetemporal L', 'transversetemporal R'}}, ...
%             'scoutfunc',   3, ...  % PCA
%             'win_std',     0, ...
%          'edit',        struct(...
%          'Comment',         'Scouts,Power', ...
%          'TimeBands',       [], ...
%          'Freqs',           [], ...
%          'ClusterFuncTime', 'before', ...
%          'Measure',         'power', ...
%          'Output',          'all', ...
%          'SaveKernel',      0));
%         
%              % Process: Power spectrum density (Welch)
%         sSources.validation.(sFOI_names{iFOI}) = bst_process('CallProcess', 'process_psd', sSources.(sFOI_names{iFOI}).FileName, [], ...
%             'timewindow',  [(sTime.Time(end) - 40), (sTime.Time(end) - 10)], ...
%             'win_length',  win_length, ...
%             'win_overlap', win_overlap, ...
%             'clusters',    {'Desikan-Killiany', {'bankssts L', 'bankssts R', 'caudalanteriorcingulate L', 'caudalanteriorcingulate R', 'caudalmiddlefrontal L', 'caudalmiddlefrontal R', 'cuneus L', 'cuneus R', 'entorhinal L', 'entorhinal R', 'frontalpole L', 'frontalpole R', 'fusiform L', 'fusiform R', 'inferiorparietal L', 'inferiorparietal R', 'inferiortemporal L', 'inferiortemporal R', 'insula L', 'insula R', 'isthmuscingulate L', 'isthmuscingulate R', 'lateraloccipital L', 'lateraloccipital R', 'lateralorbitofrontal L', 'lateralorbitofrontal R', 'lingual L', 'lingual R', 'medialorbitofrontal L', 'medialorbitofrontal R', 'middletemporal L', 'middletemporal R', 'paracentral L', 'paracentral R', 'parahippocampal L', 'parahippocampal R', 'parsopercularis L', 'parsopercularis R', 'parsorbitalis L', 'parsorbitalis R', 'parstriangularis L', 'parstriangularis R', 'pericalcarine L', 'pericalcarine R', 'postcentral L', 'postcentral R', 'posteriorcingulate L', 'posteriorcingulate R', 'precentral L', 'precentral R', 'precuneus L', 'precuneus R', 'rostralanteriorcingulate L', 'rostralanteriorcingulate R', 'rostralmiddlefrontal L', 'rostralmiddlefrontal R', 'superiorfrontal L', 'superiorfrontal R', 'superiorparietal L', 'superiorparietal R', 'superiortemporal L', 'superiortemporal R', 'supramarginal L', 'supramarginal R', 'temporalpole L', 'temporalpole R', 'transversetemporal L', 'transversetemporal R'}}, ...
%             'scoutfunc',   3, ...  % PCA
%             'win_std',     0, ...
%          'edit',        struct(...
%          'Comment',         'Scouts,Power', ...
%          'TimeBands',       [], ...
%          'Freqs',           [], ...
%          'ClusterFuncTime', 'before', ...
%          'Measure',         'power', ...
%          'Output',          'all', ...
%          'SaveKernel',      0));
% 
%     end

end